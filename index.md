Time stands still when I code.

I’m a full-stack python developer with industry experience in building websites and working with data in various ways.

I have also taken classes in Database Management and Data Visualization and have April 2021 handed in the final assignment in my last programming class; Advanced Data Structures and Algorithms at Foothill College. As I’m finishing my CS degree, I’d like to start working as a programmer instead of sneaking a few hours after a full day at work.

Constantly Learning — Consistently Problem Solving — Constructively Coding

## Skills
Database Coding: Python, R, SQL
Data Manipulation and Visualization: Tableau, Excel
Web Coding HTML, CSS, JavaScript

## Projects
Here is a sample, more at [my GitHub repository](https://github.com/peayah)

### Project 1
Created a function that solve a subset sum problem for any list of integers and a predetermined total. Am able to use to find the optimal combination of integers from a given list to either get close to or hit a total. Could be used to select the optimal combination of packages of different weights to hit a max weight or find a combination of songs that to fill a predetermined runtime. 
Class Project. Link to code: Upon request

```Sublist ----------------------------- 
  Sum: 147
  item[0] = 20  item[1] = 12  item[2] = 22  
  item[3] = 15  item[4] = 25  item[6] = 29  
  item[8] = 11  item[9] = 13
  
  Sublist ----------------------------- 
  Sum: 3513
  item[0] = Carrie Underwood -> Cowboy Casanova: 3:56  
  item[1] = Carrie Underwood -> Quitter: 3:40  
  item[2] = Rihanna -> Russian Roulette: 3:48  
  item[3] = Foo Fighters -> All My Life: 4:23  
  item[4] = Foo Fighters -> Monkey Wrench: 3:50  
  item[5] = Eric Clapton -> Pretending: 4:43  
  item[6] = Eric Clapton -> Bad Love: 5:08  
  item[7] = Howlin' Wolf -> Everybody's In The Mood: 2:58  
  item[9] = Reverend Gary Davis -> Samson and Delilah: 3:36  
  item[10] = Reverend Gary Davis -> Twelve Sticks: 3:14  
  item[11] = Roy Buchanan -> Hot Cha: 3:28  
  item[12] = Roy Buchanan -> Green Onions: 7:23  
  item[13] = Janiva Magness -> I'm Just a Prisoner: 3:50  
  item[14] = Janiva Magness -> You Were Never Mine: 4:36
```

### Project 2
Created a function that travels through a maze built from lists to add edges that when fed into Dijkstra will find shortest path. And also list the coordinates the maze traveller has to pass through to get from start to finish. Class Project. Link to code: Upon request

![Sample maze 15 x 15](/assets/images/15x15.png)

And the solution as a list.

```[(7, 0), (8, 0), (9, 0), (9, 1), (9, 2), (8, 2), (8, 1), (7, 1), (6, 1), 
(6, 0), (5, 0), (4, 0), (3, 0), (2, 0), (1, 0), (0, 0), (0, 1), (1, 1), 
(2, 1), (3, 1), (4, 1), (4, 2), (3, 2), (3, 3), (3, 4), (2, 4), (2, 3), 
(2, 2), (1, 2), (1, 3), (0, 3), (0, 4), (1, 4), (1, 5), (2, 5), (3, 5), 
(4, 5), (4, 4), (4, 3), (5, 3), (5, 2), (6, 2), (7, 2), (7, 3), (6, 3), 
(6, 4), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (6, 8), (7, 8), (7, 7), 
(8, 7), (8, 6), (8, 5), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9), (8, 9), 
(8, 10), (9, 10), (10, 10), (10, 11), (11, 11), (11, 12), (11, 13), 
(11, 14), (12, 14)] [(7, 0), (8, 0), (9, 0), (9, 1), (9, 2), (8, 2), 
(8, 1), (7, 1), (6, 1), (6, 0), (5, 0), (4, 0), (3, 0), (2, 0), (1, 0), 
(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (4, 2), (3, 2), (3, 3), 
(3, 4), (2, 4), (2, 3), (2, 2), (1, 2), (1, 3), (0, 3), (0, 4), (1, 4), 
(1, 5), (2, 5), (3, 5), (4, 5), (4, 4), (4, 3), (5, 3), (5, 2), (6, 2), 
(7, 2), (7, 3), (6, 3), (6, 4), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), 
(6, 8), (7, 8), (7, 7), (8, 7), (8, 6), (8, 5), (9, 5), (9, 6), (9, 7), 
(9, 8), (9, 9), (8, 9), (8, 10), (9, 10), (10, 10), (10, 11), (11, 11), 
(11, 12), (11, 13), (11, 14), (12, 14)]
```

![Sample maze 9 x 9](/assets/images/9x9.png)

 the solution as a list.

```[(4, 0), (5, 0), (5, 1), (5, 2), (5, 3), (6, 3), (6, 2), (6, 1), (6, 0), 
(7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (6, 5), (5, 5), (5, 4), 
(4, 4), (4, 3), (3, 3), (3, 2), (3, 1), (3, 0), (2, 0), (1, 0), (1, 1), 
(0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (2, 4), (2, 5), (3, 5), (4, 5), 
(4, 6), (5, 6), (5, 7), (4, 7), (3, 7), (3, 6), (2, 6), (2, 7), (1, 7), 
(1, 8), (2, 8), (3, 8)] [(4, 0), (5, 0), (5, 1), (5, 2), (5, 3), (6, 3), 
(6, 2), (6, 1), (6, 0), (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), 
(6, 5), (5, 5), (5, 4), (4, 4), (4, 3), (3, 3), (3, 2), (3, 1), (3, 0), 
(2, 0), (1, 0), (1, 1), (0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (2, 4), 
(2, 5), (3, 5), (4, 5), (4, 6), (5, 6), (5, 7), (4, 7), (3, 7), (3, 6), 
(2, 6), (2, 7), (1, 7), (1, 8), (2, 8), (3, 8)]
```

### Project 3
Description: Code that lazy-delete in Binary Search Trees. Traverses tree and is able to differentiate between not deleted, lazy-deleted and hard deleted nodes. 
Class Project. Link to code: Upon request

Lazy Deletion in Binary Search Trees

```Populate:
Tree size:  6 
Hard size:  6
 50
 L --- 20
        L --- 10
        R --- 30
 R --- 70
        L --- 60

Soft delete 20
Tree size:  5 
Hard size:  6
 50
 L --- 20  deleted
        L --- 10
        R --- 30
 R --- 70
        L --- 60

Collect Garbage (Hard delete)
Tree size:  5 
Hard size:  5
 50
 L --- 30
        L --- 10
 R --- 70
        L --- 60

Add 22
Tree size:  6 
Hard size:  6
 50
 L --- 30
        L --- 10
               R --- 22
 R --- 70
        L --- 60

Lazy-remove 22.
Tree size:  5 
Hard size:  6
 50
 L --- 30
        L --- 10
               R --- 22  deleted
 R --- 70
        L --- 60

Re-insert 22
Hard size should not change.
Tree 1 size:  6 
Hard size:  6
 50
 L --- 30
        L --- 10
               R --- 22
 R --- 70
        L --- 60
```
